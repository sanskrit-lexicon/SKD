#-*- coding:utf-8 -*-"""verb_ec.py  """from __future__ import print_functionimport sys, re,codecsimport transcodertranscoder.transcoder_set_dir('transcoder')slp_from = "aAiIuUfFxXeEoOMHkKgGNcCjJYwWqQRtTdDnpPbBmyrlvSzsh"slp_to =   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvw"slp_from_to = str.maketrans(slp_from,slp_to)def transcode_line(x,tranin,tranout): """ For VCP. Take into account xml-like markup """ if re.search(r'^\[Page.*?\]$',x):  return x parts = re.split(r'(<[^>]*>)',x) newparts = [] for part in parts:  if part.startswith('<'):   newparts.append(part)  else:   newpart = transcoder.transcoder_processString(part,tranin,tranout)   newparts.append(newpart) y = ''.join(newparts) return yclass Verbobj(object): def __init__(self,line):  line = line.rstrip('\r\n')  mL = re.search(r' L=(.*?),',line)  mk1 = re.search(r' k1=(.*?),',line)  if mL and mk1:   self.L = mL.group(1)   self.k1 = mk1.group(1)  else:   self.L = None   self.k1 = None def eq(self,entry):  return (self.L == entry.L) and (self.k1 == entry.k1) def toString(self,tranin,tranout):  k1a = transcoder.transcoder_processString(self.k1,tranin,tranout)  s = '%s,%s' %(k1a,self.L)  return sdef init_verbs(filein): # slurp lines with codecs.open(filein,encoding='utf-8',mode='r') as f:  lines = [line.rstrip('\r\n') for line in f] recs = [] kprev = None for line in lines:  rec = Verbobj(line)  if rec.L:   recs.append(rec) print('init_verbs:',len(recs),'records from',filein) return recsclass ECverb(object): dk = {}  # dictionary into Ecverb based on headword dL = {}  # dictionary into Ecverb based on Cologne id # equivalence classes should be disjoint on L # we allow possibility that they are # This can be called with an empty string! def __init__(self,line):  line = line.rstrip('\r\n')  parts = line.split(';')  self.entries = []  if line == '':   return  dk = ECverb.dk # for convenience  dL = ECverb.dL  for part in parts:   k,L = part.split(',')   entryline = ' k1=%s, L=%s,' %(k,L)   entry = Verbobj(entryline)   self.entries.append(entry)   #if k not in dk:   # dk[k] = []   #dk[k].append(self)   if k in dk:    if dk[k] != self:     print('ECverb Warning: headword %s appears in two classes' %k)   dk[k] = self   if L in dL:    if dL[L] != self:     print('ECverb ERROR: cologne ID %s appears in two classes' %L)   dL[L] = self def contains(self,entry1):  for entry in self.entries:   if entry.eq(entry1):    return True def toString(self,tranin,tranout):    #a = ['%s,%s' %(entry.k1.toString(tranout),entry.L) for entry in self.entries]  a = [entry.toString(tranin,tranout) for entry in self.entries]  return ';'.join(a)def init_manual_ecs(filein): with codecs.open(filein,encoding='utf-8',mode='r') as f:  lines = [line.rstrip('\r\n') for line in f if not line.startswith(';')] recs = [] for line in lines:  rec = ECverb(line)  recs.append(rec) return recsdef get_dup_keys(recs1): d = {} for irec1,rec1 in enumerate(recs1):  k = rec1.k1  if k not in d:   d[k] = []  d[k].append(rec1) return ddef add_dup_ecs(ecs,dups): dupkeys = dups.keys() for k in dupkeys:    verbrecs = dups[k]  # list of entries  if k in ECverb.dk:   # merge verbrecs into existing class   ec = ECverb.dk[k]   for verbrec in verbrecs:    if not ec.contains(verbrec):     ec.entries.append(verbrec)  else: # k not in ECverb.dk:   # make an ECverb object which whose entries are the verbrecs list   ec = ECverb('')   # add to the list of ecs   ecs.append(ec)   # initialize the entries   ec.entries = verbrecsdef write(fileout,ecs,tranout): tranin = 'slp1' n = 0 nflag = 0 neq = 0 with codecs.open(fileout,"w","utf-8") as f:  for ec in ecs:   out = ec.toString(tranin,tranout)   f.write(out+'\n') print(len(ecs),"records written to",fileout)if __name__=="__main__":  tranout = sys.argv[1] # deva or slp1 filein = sys.argv[2] #  xxx_verb1  filein1 = sys.argv[3] #  xxx_ecs_manual.txt fileout = sys.argv[4] # xxx_ecs.txt recs = init_verbs(filein) dups = get_dup_keys(recs) print("%s distinct headwords, from %s records"%(len(dups.keys()),len(recs))) ecs = init_manual_ecs(filein1) print(len(ecs),"manual equivalence classes") add_dup_ecs(ecs,dups) print(len(ecs),"total equivalence classes") write(fileout,ecs,tranout) exit(0) recs1 = merge_dups(recs) print(len(recs1),'records after merging duplicate headwords') check_unique(dictlo,recs1) #return recs1 #mergerecs = merge(vcp_recs,skd_recs,manual) write(fileout,mergerecs,tranout)